package shop.microservices.core.product;

import jakarta.validation.ConstraintViolation;
import jakarta.validation.Validation;
import jakarta.validation.Validator;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;
import shop.microservices.core.product.persistence.ProductEntity;

import java.util.Set;
import java.util.stream.Stream;

import static org.assertj.core.api.AssertionsForInterfaceTypes.assertThat;
import static org.junit.jupiter.api.Assertions.*;

public class ProductValidationTests {

    private Validator validator;

    @BeforeEach
    void setUp() {
        try (var validatorFactory = Validation.buildDefaultValidatorFactory()) {
            validator = validatorFactory.getValidator();
        }
    }

    @ParameterizedTest
    @MethodSource("provideInvalidProductEntities")
    void testProductEntityValidationNegative(ProductEntity productEntity, int expectedViolationCount, String[] expectedMessages) {
        Set<ConstraintViolation<ProductEntity>> violations = validator.validate(productEntity);

        assertFalse(violations.isEmpty());
        assertEquals(expectedViolationCount, violations.size());
        assertThat(violations)
                .extracting(it -> it.getPropertyPath() + " " + it.getMessage())
                .containsExactlyInAnyOrder(expectedMessages);
    }

    @ParameterizedTest
    @MethodSource("provideValidProductEntities")
    void testProductEntityValidationPositive(ProductEntity productEntity) {
        Set<ConstraintViolation<ProductEntity>> violations = validator.validate(productEntity);

        assertTrue(violations.isEmpty());
    }

    private static Stream<Arguments> provideInvalidProductEntities() {
        return Stream.of(
                Arguments.of(
                        new ProductEntity(-1, "", 0),
                        3,
                        new String[]{
                                "name size must be between 5 and 100",
                                "weight must be greater than or equal to 1",
                                "productId must be greater than or equal to 1"
                        }
                ),
                Arguments.of(
                        new ProductEntity(0, "Test name", -1),
                        2,
                        new String[]{
                                "weight must be greater than or equal to 1",
                                "productId must be greater than or equal to 1"
                        }
                ),
                Arguments.of(
                        new ProductEntity(1, "A", 1),
                        1,
                        new String[]{
                                "name size must be between 5 and 100"
                        }
                )
        );
    }

    private static Stream<Arguments> provideValidProductEntities() {
        return Stream.of(
                Arguments.of(new ProductEntity(1, "Water", 4)),
                Arguments.of(new ProductEntity(2, "Valid Product Name", 10)),
                Arguments.of(new ProductEntity(100, "Another Valid Product", 1))
        );
    }
}